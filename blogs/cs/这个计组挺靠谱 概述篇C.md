---
title: 这个计组挺靠谱·概述篇（三）
date: 2023-03-12
cover: https://pic.imgdb.cn/item/640ef0a6f144a0100788ae00.jpg
author: Yxw
tags:
 - 计组
categories:
 -  计算机基础
---

## 前言

> 本系列记录学习计组时的知识点梳理，我更喜欢采用讲故事的方式来表达我对知识点的理解。若文章所写之处过于繁杂，可忽略本篇:blush: :blush:





## 一、计算机的工作过程（重中之重）

上个篇章我们详细介绍了计算机各个硬件的组成部分，整体上已经有了一个感性的认知，但如果单独去记忆难免有些抽象，当我们将其组合起来之后，模拟一下它的运行流程，你才会有更深层次的认知。

讲述其运行过程之前，要先说一个知识点：**指令的组成**。

我们知道，**指令**就是我们人类给计算机下达的命令，也是控制器所要执行的东西。首先指令本身作为二进制数据存在内存当中无疑，但思考一下，它的含义是什么呢:thinking:？想想，控制器分析完指令后干什么去了？是不是去操作运算器运算去了啊:smile:。

诶，那指令到底是干什么的？是不是可以理解为：指令的含义是操作内存中的某个数呢？咱们先从中文语法的角度去理解一个动作哈，比如说：**揍他**。这个简单的命令包含哪几部分呢？很显然：**动词和名词**，动词打是你要执行的动作，名词他是受到命令执行的对象。OK,那计算机的指令也是一样的咯。它需要告诉计算机，我要执行什么动作，执行的这个动作的受作用群体是什么？

至此我们引出两个专业术语，执行的动作我们称之为：**操作码**，执行的动作的受作用群体称之为：**操作数**。至于为什么要用“码”字结尾，很简单，指令的本质是一串二进制数字，有人给它从中间切了一刀，分成两段。第一段表示操作码，第二段表示操作数，本身就是二进制代码，所以会以“码”字结尾。:smirk:

但是多数情况下吧，指令却是这样组成的。比如说：**010111000011**这一段二进制代码，我们从第四个位置开始切割，分开后便成了：0101和11000011。0101就是操作码，表示我要执行什么动作，如加减乘除操作。但你要操作的数据呢:thinking:，它会给你存到内存中的某一个位置，而这里的11000011表示的就不是操作数啦，而是操作数的门牌号，即**内存地址**。那这玩意儿我们叫它：**地址码**。

故看到以下知识点也不用惊讶！！！一定要注意，**地址码和操作码是两回事**！！！



### 知识点一

- 指令由：操作数和操作码组成
- 指令由：操作码和地址码组成



由此我们来分析一段程序在计算机中的运行流程吧:smirk:



```c
int a = 2, b = 2, c = 1, y = 0;
void main(){
	y = a * b + c;
}
```



程序如上，我想不需要我来解释他的作用了，下图是它在内存中的指令存储。



![指令存储图](https://pic.imgdb.cn/item/640dc96af144a010078d1929.jpg)



由图可知，若想执行完main函数中的运算操作，需要指令五条指令，也就是说这个运算的功能就是由这五条指令组成的**指令集**。

下面我们来详细地分析一下计算机执行指令的具体流程



> 第一条指令：取数a放至ACC中

![ppMXomn.png](https://s1.ax1x.com/2023/03/13/ppMXomn.png)



初始时：PC计数器需指向第一条指令地址，即 PC = 0

①控制器将PC计数器中指令的内存地址传给MAR寄存器，此时MAR寄存器中的值为0

②根据MAR寄存器中存放的内存地址，从存储体中读取相应的数据

③读取到数据后，将数据返还给MDR寄存器，此时MDR寄存器中的值为000001 0000000101（即第一条指令）

④MDR寄存器拿到指令后，控制器操控MDR，让其把指令传给IR寄存器，此时IR寄存器的值为 000001 0000000101

⑤IR寄存器存入指令后，取值操作结束，此时**PC计数器自动加1**，控制器又将IR寄存器中所存储指令的**操作码**送给CU控制单元。CU分析指令后发现，这是**取数指令**

⑥控制器再将IR寄存器中指令的地址码传给MAR寄存器中，此时MAR寄存器中的值为0000000101，即十进制数5

⑦存储体根据MAR存放的内存地址，读取到对应内存单元中的值：0000000000000010，即为2

⑧存储体读到的数值后，将其放入MDR寄存器中，即此时MDR寄存器中的值为：2

⑨控制器将MDR中的数据放入运算器中的ACC累加器中，至此第一条指令执行结束。



> 第二条指令：乘b得ab，存于ACC中

![ppMXbkV.png](https://s1.ax1x.com/2023/03/13/ppMXbkV.png)



上一条指令第四步执行完后，取指令结束，PC计数器自动加1，PC = 1；执行后，ACC = 2

①控制器将PC计数器中指令的内存地址传给MAR寄存器，此时MAR寄存器中的值为1

②根据MAR寄存器中存放的内存地址，从存储体中读取相应的数据

③读取到数据后，将数据返还给MDR寄存器，此时MDR寄存器中的值为000100 0000000110（即第二条指令）

④MDR寄存器拿到指令后，控制器操控MDR，让其把指令传给IR寄存器，此时IR寄存器的值为 000100 0000000110

⑤IR寄存器存入指令后，取值操作结束，此时**PC计数器自动加1**，控制器又将IR寄存器中所存储指令的**操作码**送给CU控制单元。CU分析指令后发现，这是**乘法指令**

⑥控制器再将IR寄存器中指令的地址码传给MAR寄存器中，此时MAR寄存器中的值为0000000110，即十进制数6

⑦存储体根据MAR存放的内存地址，读取到对应内存单元中的值：0000000000000011，即为3

⑧存储体读到的数值后，将其放入MDR寄存器中，即此时MDR寄存器中的值为：3

⑨控制器将MDR中的数据放入运算器中的MQ寄存器中，此时MQ寄存器中的值为：3。

⑩控制器将ACC累加器中的值放入X通用寄存器中，即X寄存器中的值为：2

⑪通过ALU进行乘法运算，将MQ和X两个寄存器中的值进行相乘，得到结果6存入ACC累加器中（注：若乘积太大，则会由MQ进行辅助存储）



> 第三条指令：加c得ab+c，存于ACC中

![第三条指令](https://pic.imgdb.cn/item/640dd191f144a010079e0b31.png)

上一条指令第四步执行完后，取指令结束，PC计数器自动加1，PC = 2；执行后，ACC = 6

①控制器将PC计数器中指令的内存地址传给MAR寄存器，此时MAR寄存器中的值为2

②根据MAR寄存器中存放的内存地址，从存储体中读取相应的数据

③读取到数据后，将数据返还给MDR寄存器，此时MDR寄存器中的值为000100 0000000111（即第三条指令）

④MDR寄存器拿到指令后，控制器操控MDR，让其把指令传给IR寄存器，此时IR寄存器的值为 000100 0000000111

⑤IR寄存器存入指令后，取值操作结束，此时**PC计数器自动加1**，控制器又将IR寄存器中所存储指令的**操作码**送给CU控制单元。CU分析指令后发现，这是**加法指令**

⑥控制器再将IR寄存器中指令的地址码传给MAR寄存器中，此时MAR寄存器中的值为0000000111，即十进制数7

⑦存储体根据MAR存放的内存地址，读取到对应内存单元中的值：0000000000000001，即为1

⑧存储体读到的数值后，将其放入MDR寄存器中，即此时MDR寄存器中的值为：1

⑨控制器将MDR中的数据放入运算器中的X通用寄存器中，此时X寄存器中的值为：1。

⑩ALU将ACC累加器中的值与X寄存器值进行相加，算出结果后存入ACC中，即ACC累加器中的值为：7



> 第四条指令：将ab+c，存于主存单元**（仔细观察存数时的不同）**

![ppMjGcQ.png](https://s1.ax1x.com/2023/03/13/ppMjGcQ.png)

上一条指令第四步执行完后，取指令结束，PC计数器自动加1，PC = 3；执行后，ACC = 7

①控制器将PC计数器中指令的内存地址传给MAR寄存器，此时MAR寄存器中的值为3

②根据MAR寄存器中存放的内存地址，从存储体中读取相应的数据

③读取到数据后，将数据返还给MDR寄存器，此时MDR寄存器中的值为000100 0000001000（即第四条指令）

④MDR寄存器拿到指令后，控制器操控MDR，让其把指令传给IR寄存器，此时IR寄存器的值为 000100 0000001000

⑤IR寄存器存入指令后，取值操作结束，此时**PC计数器自动加1**，控制器又将IR寄存器中所存储指令的**操作码**送给CU控制单元。CU分析指令后发现，这是**存数指令**

⑥控制器再将IR寄存器中指令的地址码传给MAR寄存器中，此时MAR寄存器中的值为0000001000，即十进制数8

⑦控制器又将ACC累加器中的值传给MDR寄存器中，即此时MDR寄存器中的值为：7

⑧存储体根据MAR寄存器中存储的地址找到对应的存储单元，即定位到内存地址为8的存储单元

⑨控制器将MDR寄存器中的值存入上一步找到的存储单元中，即此时内存地址为8的存储单元中，存储的数据为7



> 第五条指令：停机

![ppMj0hT.png](https://s1.ax1x.com/2023/03/13/ppMj0hT.png)

上一条指令第四步执行完后，取指令结束，PC计数器自动加1，PC = 4

①控制器将PC计数器中指令的内存地址传给MAR寄存器，此时MAR寄存器中的值为4

②根据MAR寄存器中存放的内存地址，从存储体中读取相应的数据

③读取到数据后，将数据返还给MDR寄存器，此时MDR寄存器中的值为000110 0000000000（即第四条指令）

④MDR寄存器拿到指令后，控制器操控MDR，让其把指令传给IR寄存器，此时IR寄存器的值为 000110 0000000000

⑤IR寄存器存入指令后，取值操作结束，此时**PC计数器自动加1**，控制器又将IR寄存器中所存储指令的**操作码**送给CU控制单元。CU分析指令后发现，这是**停机指令**

⑥**最后利用中断机制通知操作系统终止该进程，程序结束**



总结：

- 在执行指令时，当完成取指操作后（即从MDR寄存器中取出指令存入IR寄存器后），PC计数器就会自动加1
- CU会从IR寄存器中提取指令中的**操作码**进行分析，这一步称为：**分析指令**
- 在运算器进行运算时，是CU发出控制信号，通知ALU进行算数运算
- 存储体从MAR读取到数据后，是CU发出控制信号，通知存储体（内存）将数据返还给MDR中
- 在取数进行运算时，整体流程是从内存中读取数据传给MDR，再传给运算器中的ACC累加器；在存数到内存时，整体流程是从ACC累加器中读取数据传给MDR，再传给MAR所指向的内存地址中的存储单元。**（仔细体会一下这个过程）**



### 知识点二

- 冯诺依曼计算机的特点：
  1. 计算机由五大部件组成
  2. 指令和数据以同等地位存于存储器，可按地址寻访
  3. 指令和数据用二进制表示
  4. 指令由操作码和地址码组成
  5. 存储程序
  6. 以运算器为中心（现代计算机一般以存储器为中心）





## 二、计算机系统的层次结构

随着计算机的发展，人们发觉若采用机器语言直接编写指令来实现功能是一件非常崩溃的事情，这种方式简直太折磨了，机器语言完全就是一种反人类的设计。

于是乎封装的思想又体现出来了，我能不能把它变得简单一点呢:thinking:。没有问题，前面我们说过指令由操作码和操作数组成，OK，我把前面的操作码代表的二进制代码用某个英文助记符来代替，后面欲操作的数用十进制数代替，这样一组合，汇编语言出来了。用了一段时间后发现，这么去玩还是有些地方用起来不舒服，那么编程语言就迅速发展，各种各样的高级语言应运而生，呈现出如今多元化的编程世界。

值得注意的是，由于只有机器语言能被机器直接执行，其余的语言不能被执行，而我们使用过程中貌似好像是直接执行出来的，实际上这是经过相应的编译程序进行翻译的结果，故我们称运行**除**机器语言的这些机器为：**虚拟机器**。

![计算机层次结构](https://pic.imgdb.cn/item/640ec4bcf144a0100734ddd1.png)



### 知识点三

- 若将一个源程序（如某高级语言程序）转化为机器语言，有三种方式：
  - 方式一：源程序--->汇编语言--->机器语言
    - 第一步：通过**编译器**，**编译程序**为**汇编语言**
    - 第二步：通过**汇编器**，**汇编程序**为**机器语言**
  - 方式二：源程序--->机器语言
    - 通过**编译器**直接**编译程序**为**机器语言**，一步到位
  - 方式三：源程序--->机器语言
    - 通过**解释器**，**解释程序**为**机器语言**
- 编译、汇编、解释程序，可统称为“翻译程序”
- 编译程序：将高级语言**一次全部**翻译为汇编语言**或**直接翻译为机器语言
- 解释程序：高级语言翻译为机器语言（**翻译一句执行依据**）
- 汇编程序：将汇编语言翻译成机器语言





## 三、计算机的性能指标

说到性能指标这个话题，就比较枯燥了，更多的都是一些概念性的东西了，大家尝试的去理解便好了，这里不一一列举知识点了，各类公式都属于重点内容了。

先说**总容量**，也就是指内存条可以容纳多少数据。前面我们说过，MAR寄存器存内存地址，反映存储单元的个数；MDR存数据，反映的是每个存储单元的大小，也就是存储字长，总容量实际上就是**单元个数 * 存储字长**。

- **总容量 = 存储单元个数 * 存储字长 bit**

举例： 若MAR是32位,MDR是8位，求总容量

答：	总容量 = 2 ^ 32 * 8 bit = 4GB



- CPU主频：CPU内数字脉冲信号振荡频率（单位：赫兹 HZ）

  CPU主频公式（时钟频率） = 1 / CPU时钟周期

  
- CPI(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数

  执行一条指令的耗时 = CPI×CPU时钟周期


举例：某CPU主频为1000Hz，某程序包含100条指令，平均来看指令的CPI=3。问该程序在该CPU上执行需要多久？

答： 100× 3 × 1/1000= 0.3 s



CPU执行时间（整个程序的耗时） = CPU时钟周期数 / 主频 = （指令条数× CPI）/ 主频




- IPS(Instructions Per Second)：每秒执行多少条指令


IPS = 主频/平均CPI


- FLOPS(Floating-point Operations Per Second)：每秒执行多少次浮点运算

> 注意：KFLOPS、MFLOPS、GFLOPS、FLOPS
>
> 这里的以K、M、G、T、P、E、Z为数量单位
>
> K=Kilo=千=10^3，M=Million=百万=10^6，G=Giga=十亿=10^9，T=Tera=万亿=10^12
>
> **新增：**P = 10^3 T ，E = 10^3 P ，Z= 10^3 P



- 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）

- 吞吐量:指系统在单位时间内处理请求的数量。

  - 它取决于信息能多快地制八内1t必-台外部设备。这些步骤中的每一步都关系存入，以及所得结果能多快地从囚仔纪―H即国的。二外TnY"0到主存，因此，系统吞吐量主要取决于主存的存取周期。

  

- 响应时间:指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。

  - 通常包括CPU时间(运行一个程序所花费的时间）与等待时间(用于磁盘访问、存储器访问、1/o操作、操作系统开销等时间)。



- **基准程序**（就是所谓的跑分软件）是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能进行比较。



> **思考题：**
>
> 问:主频高的CPU一定比主频低的CPU快吗?
>
> 答：不一定，如两个CPU，A的主频为2GHz，平均CPI=10;B的主频1GHz，平均CPI=1...
> 
>
>
> 问:若A、B两个CPU的平均CPI相同，那么A一定更快吗?
>
> 答：也不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法;而B支持乘法指令。
>
> 问:基准程序执行得越快说明机器性能越好吗?
> 答：基准程序中的语句存在频度差异，运行结果也不能完全说明问题